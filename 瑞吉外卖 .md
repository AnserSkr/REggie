# 瑞吉外卖

[黑马瑞吉外卖项目](https://blog.csdn.net/weixin_46267445/article/details/124691023)

# **项目引入**

### **前置知识：**Java基础知识—>Java Web—>MySQL—>SSM(Spring、Spring MVC、MyBatis)—>Spring Boot—>Maven

## **项目目标：**

- 了解企业项目开发的完整流程，增长开发经验
- 了解需求分析的过程，提高分析和设计能力
- 对所学技术进行灵活应用，提高编码能力
- 解决各种异常情况，提高代码调试能力

### **软件开发介绍**

**软件开发流程**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled.png)

**需求分析：**

**产品原型：**通过网页形式展示，当前开发的项目大体的结构。包括项目涉及了哪些页面，页面结构是是什么样的，是列表页面还是表单页面，点击按钮后查询什么样的数据，产生什么效果。

**需求规格说明书：**Word文档，通过文档展示项目有哪些功能。

**设计：**

产品文档、概要设计、详细设计

**UI界面设计：**将项目的界面效果展示出来，最终开发的效果与UI界面一致。

**数据库设计：**涉及当前项目用到哪些数据库，涉及什么表，表的字段是什么样的

**编码：**

**项目代码：由软件开发人员完成**

**单元测试：在完成功能后做好相应的单元测试**

**测试：**

**测试用例：**由测试人员编写测试用例

**测试报告：**由测试人员根据测试用例完成测试报告

**上线运维：由运维人员完成**

**软件环境安装、配置：**

**角色分工（细化的分工）**

**小公司人员不足，一人兼多职**

**项目经理：管理人员。**对整个项目负责，任务分配，人员调度、把控进度。

**产品经理：前期最早介入的人员。**进行需求调研，输出需求调研文档、设计完成产品原型等

**UI设计师：**根据产品经理设计的原型**输出界面效果图**。

**架构师：从技术层面整体把控项目。如**项目整体架构设计、技术选型，以及为什么使用该技术等

**开发工程师：**代码实现

**测试工程师：**编写测试用例，输出测试报告

**运维工程师：处于项目后期的人员。**软件环境搭建、项目上线

**软件环境**

**开发环境(development)：**开发人员在开发阶段使用的环境，一般外部用户无法访问

**如Mysql数据库，sql都保存在个人PC，别人无法获取。**或者数据库保存在一台专门的服务器，使用的应用都是服务器上的应用。**数据库和应用以及服务器都属于开发环境**

**测试环境(testing)：**专门给测试人员使用的环境，用于测试项目，一般外部用户无法访问。如专门安装了测试应用的服务器等都属于测试环境

**生产环境(production)：**即正式对外提供服务的线上环境，任何人都可以访问。**由运维人员将开发的内容部署到服务器上，服务器就是生产环境。**

## **项目介绍**

### **外卖项目总介绍**

**项目介绍：**从功能需求上介绍项目

本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，**包括系统管理后台和移动端应用两部分**。

其中**系统管理后台**主要提供给餐饮企业**内部员工使用，**可以对餐厅的菜品、套餐、订单等进行管理维护。

**移动端应用**主要提供给**消费者使用**，可以在线浏览菜品、添加购物车、下单等。

- **效果展示**
  
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%201.png)
    

**本项目共分为3期进行开发：**

> **第一期主要实现基本需求**，其中移动端应用通过H5实现，会自动根据手机页面的大小自适应调整，用户可以通过手机浏览器访问。
**第二期主要针对移动端应用进行改进**，使用微信小程序实现，用户使用起来更加方便。
**第三期主要针对系统进行优化升级**，提高系统的访问性能。
> 

**产品原型展示：用网页方式直观展示出来，项目具有哪些功能，页面，以及页面的结构。**

**产品原型，就是一款产品成型之前的一个简单的框架，就是将页面的排版布局展现出来，使产品的初步构思有一个可视化的展示。**

**产品原型是项目开发初级阶段，产品经理提供的，未经UI设计师修改的仅有结构的简易前端页面()**，可以更加直观的了解项目的需求和提供的功能。

**PS：产品原型仅用于展示项目功能，并不是最终页面的效果**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%202.png)

- **简易结构模型**
  
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%203.png)
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%204.png)
    

**技术选型：使用哪些技术栈**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%205.png)

Nginx是一个类似Tomcat的服务器，但有很大的区别。**Nginx主要部署的是一些静态资源，后期还会做Tomcat的集群。**

**集群就会设计到Nginx的使用，比如前端发送一个Nginx的请求，首先请求到Nginx服务器，然后再由Nginx将请求分发到多个Tomcat服务上去。**

**Spring Session：进行集群是涉及到一个Session共享的问题，通过此技术解决。**

**Swagger：后期优化时会对项目进行拆分，变成一个前后端分离的项目，会使用此技术**

**Redis：一般用来做缓存，项目优化过程会引入**

**功能架构：用图形化方式展示项目有哪些功能**

**主要分移动端的前台，以及商家端的后台的主要功能。以及更加细分的功能**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%206.png)

**角色：使用项目的人员分类**

**后台系统管理员(最高权限)：**登录后台管理系统，拥有后台系统中的所有操作权限

**后台系统普通员工：**登录后台管理系统，对菜品、套餐、订单等进行管理

**客户端用户：**登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等

### **开发环境搭建**

**数据库环境的搭建**

**新建一个专门用于该项目的数据库 reggie**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%207.png)

**表结构直接导入：**已经提供好了(资料/数据模型/db_reggie.sql)

**使用图形界面：选中数据库，右键，运行SQL—>找到SQL文件—》导入。**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%208.png)

**也可以使用MySQL命令：use reggie;—>source ./db_reggie.sql;    通过命令导入表结构时，执行sql文件的路径上不要有中文**

**成功后，右键书库库，刷新**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%209.png)

| 序号 | 表名 | 说明 | 作用 |
| --- | --- | --- | --- |
| 1 | employee | 员工表 | 存储登陆界面的员工账号信息 |
| 2 | category | 菜品和套餐分类表 | 存储分类界面的类别具体信息 |
| 3 | dish | 菜品表 | 存储菜品界面的菜品具体信息 |
| 4 | setmeal | 套餐表 | 存储套餐界面的套餐具体信息 |
| 5 | setmeal dish | 套餐菜品关系表 | 存储具体单个套餐中具有的多个菜品信息 |
| 6 | dish_flavor | 菜品口味关系表 | 存储单个菜品的口味信息 |
| 7 | user | 用户表(C端) | 存储消费者用户的账号信息 |
| 8 | address book | 地址簿表 | 存储用户设定的地址信息 |
| 9 | shopping_cart | 购物车表 | 存储用户操作的购物车信息 |
| 10 | orders | 订单表 | 存储用户下单后的下单数据 |
| 11 | order_detail | 订单明细表 | 存储用户个人订单的订单信息 |

**Maven项目的搭建**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2010.png)

**创建完项目后，注意检查项目的编码、maven仓库配置、jdk配置等**

**Maven：setting—》Bulid—》build Tools—>Maven。修改Maven位置，Maven设置文件位置。以及Runner改为自己的JDK版本**

**编码格式：Edits—》file Encoding—》全部修改为UTF-8，同时修改idea界面右下角编码为UTF-8**

**Jdk版本配置：Project Structures—》Project 修改为自己的JDK版本**

### **项目的初步构建**

- **项目错误查看技巧**
  
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2011.png)
    
- **Pom.xml：引入项目需要使用的依赖信息**
  
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.7.3</version>
            <relativePath/> <!-- lookup parent from repository -->
        </parent>
    
        <groupId>com.wenjin</groupId>
        <artifactId>Reggie</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    
        <properties>
            <java.version>1.8</java.version>
        </properties>
    
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>
    
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
    
            **<dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
            </dependency>
    
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>3.4.2</version>
            </dependency>
    
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
            </dependency>
    
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.7</version>
            </dependency>
    
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid-spring-boot-starter</artifactId>
                <version>1.2.8</version>
            </dependency>
    
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <scope>runtime</scope>
            </dependency>
    
            <dependency>
                <groupId>commons-lang</groupId>
                <artifactId>commons-lang</artifactId>
                <version>2.6</version>
            </dependency>**
    
        </dependencies>
    
        <build>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                </plugin>
            </plugins>
        </build>
    
    </project>
    ```
    
- **application.xml：设定SpringBoot的约定配置**
  
    ```yaml
    #指定项目启动使用的端口
    server:
      port: 8080
    
    spring:
      #指定应用的名称
      application:
        name: reggie_take_out
      #设置数据源的信息
      datasource:
        ~~druid:~~
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
        username: root
        password: root
    		type: com.alibaba.druid.pool.DruidDataSource
    
    mybatis-plus:
      configuration:
        #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射
        #如 表名 address_book --> 类名AddressBook  字段名user_name --> 属性名UserName
        map-underscore-to-camel-case: true
        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
      global-config:
        db-config:
          id-type: ASSIGN_ID
    ```
    
- **创建SpringBoot启动类：用做项目启动的入口**
  
    ```java
    **@Slf4j**
    @SpringBootApplication
    public class ReggieApplication {
        public static void main(String[] args) {
            SpringApplication.run(ReggieApplication.class);
            **log.info("项目启动成功");**
        }
    }
    ```
    
    **Lombok提供了一个@Slf4j 的日志注解，可以通过注解中内置的 log对象 调用日志信息的输出操作**
    
    - **错误提示：无法配置dataSource：URL属性没有指定并且不能嵌入dataSource。导致dataSource不能配置**
      
        说明数据源配置出了问题：将老版的直接使用druid配置数据源修改掉，**使用新版的type指定数据源类**
        
        ```yaml
          #设置数据源的信息
          datasource:
            ~~**druid:**~~
            driver-class-name: com.mysql.cj.jdbc.Driver
            url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
            username: root
            password: root
        		**type: com.alibaba.druid.pool.DruidDataSource**
        ```
    
- **导入前端界面**
  
    **前端资源已经提供好了，直接使用即可。资料/前端资源  —》font目录：移动端用户界面    backend目录：后端管理界面**
    
    **在SpringBoot中推荐将前端静态资源放置到resources的static文件夹中。**
    
    **SpringBoot默认配置了Statis文件夹下的所有资源允许被访问。但不在static目录中其他静态页面经由SpringMVC，因为未配置资源映射，所以都不允许进行访问。**
    
    **创建SpringMVC的配置类，配置SpringMVC的资源映射和拦截器**
    
    ```java
    @Slf4j
    @Configuration //添加注解说明是Spring配置类
    public class SpringMvcSupportConfig extends WebMvcConfigurationSupport {
    
        /**
         * 为我们非static的静态资源进行映射
         * @param registry
         */
        @Override
        protected void addResourceHandlers(ResourceHandlerRegistry registry) {
            log.info("开启SpringMVC的静态资源映射");
            **registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");
            registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");**
        }
    }
    ```
    

# **项目开发**

## **后台登录与退出功能day01**

### **登录功能：**

**1. 需求分析：**

根据最初产品经理创建好的 简易版的前端功能页面，进行分析。根据原型分析需要什么数据表，网页请求的路径，以及数据响应的格式，怎么进行操作。

**根据登陆页地址：[http://localhost/backend/page/login/login.html](http://localhost/backend/page/login/login.html)的请求可得，点击登录后请求的是localhost/employee/login页面，**

**传递的JSON格式数据为{username: "admin", password: "123456"}**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2012.png)

简单查看一下Login页面的源码信息。

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2013.png)

**2.代码开发：**

- 准备工作，根据数据库信息，**创建Employee实体类，~~EmployeeMapper.xml文件~~，EmployeeMapper接口，EmpolyeeService接口，EmployeeServiceImpl实现类**
  
    Employee实体类
    
    ```java
    @Data
    public class Employee {
        private static final long serialVersionUID = 1L;
    
        private Long id;
        private String username;
        private String name;
        private String password;
        private String phone;
        private String sex;
        private String idNumber;//身份证号码
        private Integer status;
        private LocalDateTime createTime;
        private LocalDateTime updateTime;
    
    		@TableField(fill = FieldFill.INSERT)
        private Long createUser;
        
        @TableField(fill = FieldFill.INSERT_UPDATE)
        private Long updateUser;
    }
    ```
    
    EmployeeMapper接口
    
    ```java
    @Mapper
    public interface EmployeeMapper extends BaseMapper<Employee> {
    }
    ```
    
    EmployeeSercvice接口
    
    ```java
    public interface EmployeeService extends IService<Employee> {
    }
    ```
    
    EmployeeSercviceImpl实现类
    
    ```java
    @Service
    public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee> implements EmployeeService {
    }
    ```
    

根据需求分析得知，请求地址为**/employee/login，返回值的Result对象要包含有操作状态码Code，数据库查询数据data，提示信息msg。三部分内容。**

- **创建通用返回结果类Result<T>**
  
    ```java
    /**
     * @Date: 2022/9/20 - 09 - 20 - 23:45
     * @Description: com.reggie.common
     * @version: 1.0
     *
     * 该类为通用的返回结果，服务端的响应都会封装为此对象
     */
    public class Result<T> {
        private Integer code;//状态编码：1成功，0或其他数字为失败
    
        private String msg;//提示消息
    
        private T data;//查询到的数据对象的JSON字符串
    
        private Map map  = new HashMap();//动态数据
    
        public static <T> Result<T> success(T object){//执行成功操作的方法
            Result<T> result = new Result<T>();
            result.data = object;
            result.code = 1;
            return result;
        }
    
        public static <T> Result<T> error(String msg){//执行失败插入的方法
            Result<T> result = new Result<T>();
            result.code = 0;
            result.msg = msg;
            return result;
        }
    
        public Result<T> add(String key,Object value){
            this.map.put(key,value);
            return this;
        }
    }
    ```
    

**创建简单的接受请求的方法，内部注入接收的对象的同时还要注入request对象，方便查询结束后将查询到的数据信息放置到session中**

```java
@Slf4j
@RestController
@RequestMapping("/employee")
public class EmployController {
    @Autowired
    EmployeeService employeeService;

    **@PostMapping("/login")
    public Result<Employee> login(HttpServletRequest request, @RequestBody Employee employee){
        return null;
    }**
}
```

**此处的登录功能较为复杂：**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2014.png)

```java
@Slf4j
@RestController
@RequestMapping("/employee")
public class EmployController {
    @Autowired
    EmployeeService employeeService;

    @PostMapping("/login")
    public Result<Employee> login(HttpServletRequest request, @RequestBody Employee employee){
        //1.根据账号名称查询账号是否注册
        LambdaQueryWrapper<Employee> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(Employee::getUsername, employee.getUsername());
        Employee emp = employeeService.getOne(lambdaQueryWrapper);
        if(emp ==null){
            return Result.error("账号未注册，请检查后再登录");
        }
        // 2.检查员工账号是否被禁用
        if(emp.getStatus()==0){
            return Result.error("员工账户已被管理员禁用，请联系管理员");
        }
        //3.对传递过来的明文密码进行MD5加密，并判断密码是否正确
        String password = employee.getPassword();
        password = DigestUtils.md5DigestAsHex(password.getBytes());
        if(!emp.getPassword().equals(password)){
            return Result.error("密码错误，请检查后再登录");
        }
        // 4.账户名密码正确，账户未被禁用，存入Session中并返回
        request.getSession().setAttribute("employee",emp.getId());
        System.out.println(emp.toString());
        return Result.success(emp);
    }
}
```

**功能测试：账号admin，密码123456**

**登录后数据会存储到前端的LocalStorage中，永久的保存，LocalStorage无有效期限制，除非手动进行删除。**[Window localStorage 属性](https://www.runoob.com/jsref/prop-win-localstorage.html)

### **退出功能**

根据前端页面的退出请求得知，退出请求的页面请求时**/emplopyee/logout**

**当点击退出按钮后，要清楚登陆状态，我们登陆状态保存的地方有两个，一个是Vue操作的LocalStorage以及Tomcat  操作Servlet时的Session域。**

将退出成功的结果提示一下

```java
/**
 * 员工退出
 * @param request
 * @return
 */
@PostMapping("/logout")
public Result<String> logout(HttpServletRequest request){
    **request.getSession().removeAttribute("emp");**
    return Result.success("退出成功");
}
```

### **后台系统页面构成与展示方式**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2015.png)

页面主要内容分为左右两部分，左侧是展示栏，右侧是查询的数据

**左侧展示栏如何实现？其他参考源码内容**

找到index页面查看页面源码，得知，在Vue中创建了JS对象，**保存了左侧五个按钮的相关信息**，如下图

**使用menuList保存对应的信息，并在EleMentUI的循环中以item做临时变量代之内部的元素。**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2016.png)

使用ElementUI提供的插件进行for循环，展示js数组的信息内容，并做界面优化

点击对应位置的按钮之后就会自动调用点击函数

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2017.png)

**此处的的IfreamURL是原本定义好的页面布局需要的参数。**

目的是为了给原本页面**一块挖空的空位置，展示传入url指向的页面。**

**IframUrl**初始值为员工管理的页面。

## 后台员工管理 day02

### 登陆状态的检测

**功能分析：**

前面我们已经完成了后台系统的员工登录功能开发，**但是还存在一个问题：用户如果不登录，直接访问其他的系统首页面，照样可以正常访问。**

**这种设计并不合理，**我们希望看到的效果应该是，**只有登录成功后才可以访问系统中的页面，如果没有登录则跳转到登录页面。**

**那么就需要使用过滤器Filter或者拦截器interceptor来进行实现。**

**代码实现流程：使用Filter过滤器**

**创建一个过滤器类LoginFilter实现Filter过滤器接口，然后重写DoFilter方法。**

**同时在SpringBoot的启动类上将增加@ServlrtComponentScan注解开启对@WebServletFilter注解的扫描**

完善处理器逻辑

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2018.png)

首先创建String数组定义不需要Filter过滤器过滤的页面，**而String[]中保存的`/backend/**`。如果不做特殊处理，Filter过滤去会把`**`以字符串形式识别，就是不过滤连接全匹配`/backend/**`的页面，这样就不能起到过统配符的作用。因此引入了`AntPathMatcher`路径匹配器，用于对字符串中的`**`通配符进行统配处理**

而对于未登录状态的页面处理，可以查看index中引用的request.js文件。可以查看到前端使用了响应拦截器**`service.interceptor.response.use`**对页面进行处理。

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2019.png)

**可以看到，对后端响应的数据，res的code以及msg进行判断，如果都符合未登录状态，则会自动的在前端进行`window.top.location.href = '/backend/page/login/login.html'`跳转**

- **具体代码**
  
    ```java
    @Slf4j
    @WebFilter(filterName = "lockCheckFilter",urlPatterns = "/*")
    public class LoginCheckFilter implements Filter {
        //路径匹配器，支持String格式的通配符
        public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();
        @Override
        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
            HttpServletRequest httpServletRequest = (HttpServletRequest) request;
            HttpServletResponse httpServletResponse = (HttpServletResponse) response;
            //1.获取请求的URI地址,并设置不进行过滤的内容
            String requestURI = httpServletRequest.getRequestURI();
    
            //定义不需要进行过滤的连接
            String[] urls = new String[]{
                    "/employee/login",
                    "/employee/logout",
                    "/backend/**",
                    "/front/**"
            };
            // 2.使用AntPathMatcher路径匹配器，对字符串**或*的通配符与requestUrl进行比对处理，该操作封装到check()中
            boolean check = check(urls, requestURI);
            // 3.如果不需要处理则放行
            if(check){
                chain.doFilter(httpServletRequest,httpServletResponse);
                return;
            }
            // 4.如果连接需要被过滤，判断是否登录
            if(httpServletRequest.getSession().getAttribute("employee") != null){
                chain.doFilter(httpServletRequest,httpServletResponse);
                return;
            }
            // 5.如果未登录，则响应数据到前端，由响应拦截器跳转到指定页面
            httpServletResponse.getWriter().write(JSON.toJSONString(Result.error("NOTLOGIN")));
            return;
    
        }
    
        /**
         * 路径匹配方法，检查本次请求是否需要被执行
         * @param urls
         * @param requestUrl
         * @return
         */
        public boolean check(String[] urls,String requestUrl){
            for(String url:urls){
                //匹配成功会返回true
                boolean match = PATH_MATCHER.match(url, requestUrl);
                if(match){
                    return true;
                }
            }
            return false;
        }
    }
    ```
    

前端页面也可以加断点调试，并且还能将鼠标移动到变量上查看对应信息，与java调试如出一辙

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2020.png)

### **新增员工**

- **功能分析：**
  
    在员工管理页面，点击添加员工按钮，会调用index中的`menuHandle`方法，跳转挖空位置的视图到添加页面**/backend/page/member/add.html**。在添加页面输入信息，点击保存后，F12查看提交的页面**/employee。进入idea此页面**查看页面源码，查看传递的参数是什么以及传递参数的过程
    
    对于员工表employee中的数据，唯一索引是username，所以就要保证username唯一。
    
    - 页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务端
    - 服务端Controller接收页面提交的数据并调用Service将数据进行保存
    - Service调用Mapper操作数据库，保存数据
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2021.png)
    
- **代码编写：**
  
    ```java
    @PostMapping
    public Result<String> addEmployee(HttpServletRequest request, @RequestBody Employee employee){
        // log.info("新增员工",employee.toString());
        //1.为员工的各项属性设置初始值
        // 员工初始密码123456，并做Md5加密处理
        String password = DigestUtils.md5DigestAsHex("123456".getBytes());
        employee.setPassword(password);
        // 员工创建时间,更新时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        // 员工的创建者
        Employee emp = (Employee) request.getSession().getAttribute("employee");
        employee.setCreateUser(emp.getId());
        employee.setUpdateUser(emp.getId());
    
        // 将员工对象保存到数据库中
        boolean save = employeeService.save(employee);
        if(save){
            return Result.success("新增员工成功");
        }else {
            return Result.error("新增员工错误");
        }
    }
    ```
    
- **异常处理**
  
    但是由于数据库设置了唯一性索引username,当我们重复添加username相同的用户时，此时程序会抛出异常:`java.sql.**SQLIntegrityConstraintViolationException**: Duplicate entry 'heniang' for key 'idx_username'`
    
    异常处理，可以在Controller方法中加入try.catch进行异常捕获，**也可以使用异常处理器进行全局异常捕获，一般项目开发常用后者**
    
    ```java
    //对增加了RestController以及Controller注解的类进行AOP的拦截
    @RestControllerAdvice(annotations = {RestController.class, Controller.class})
    @Slf4j
    public class GlobalExceptionHandler {
    
        @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
        public Result<String> doSQLException(SQLIntegrityConstraintViolationException ex){
            log.error(ex.getMessage());
            **if(ex.getMessage().contains("Duplicate entry")){
                //将字符串按” “分割，并存入数组中
                String[] split = ex.getMessage().split(" ");
                String msg = "用户名 "+split[2]+" 已存在，请换一个";
                return Result.error(msg);
            }**
            return Result.error("未知错误");
        }
    }
    ```
    

**注意：**

1、根据产品原型(前端页面)明确业务需求

2、重点分析数据的流转过程和数据格式

3、通过debug断点调试跟踪程序执行过程

### 员工信息的分页查询

- **需求分析**
  
    系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。
    
    点击下方的分页工具条可以完成分页功能
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2022.png)
    
    根据前端代码分析，页面请求数据发送的是**http://localhost/employee/page?page=1&pageSize=10**
    
    **代码开发**
    
    在开发代码之前，需要梳理一下整个程序的执行过程:
    
    - 页面发送ajax请求，将分页查询参数(page.pageSize、name)提交到服务端
    - 服务端Controller接收页面提交的数据并调用Service查询数据
    - Service调用Mapper操作数据库，查询分页数据
    - Controller将查询到的分页数据响应给页面
    - 页面接收到分页数据并通过ElementUI的Table组件展示到页面上
    
    当我们查看源码时候会清晰的看到，**后端发送分页请求时传递的数据时json形式的通过params参数进行传递，但是最后却以get地址形式进行了发送，原因是什么呢？**
    
    **原因是**前端的页面中的request中将Axios请求转交给了service来处理，同时还增加了一个`service.interceptors.request.use`前端发送请求时的一个全局请求拦截器。在拦截器中专门对于get请求传递json数据的情况使用特定方式进行了处理，将json格式的数据转换为了url后的参数。**所以就出现了，明明是json数据却变为了url明文的情况**
    
- **代码编写**
  
    引入分页插件
    
    ```jsx
    @Configuration
    @MapperScan("com.reggie.mapper")
    public class MybatisPlusConfig {
        /**
         * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)
         */
        @Bean
        public MybatisPlusInterceptor mybatisPlusInterceptor() {
            MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
            interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));
            return interceptor;
        }
    
        @Bean
        public ConfigurationCustomizer configurationCustomizer() {
            return configuration -> configuration.setUseDeprecatedExecutor(false);
        }
    }
    ```
    
    查询员工逻辑代码
    
    ```jsx
    @GetMapping("/page")
    public Result<IPage> pagination(Integer page,Integer pageSize,String name){
        log.info("当前页:"+page+" 每页大小 "+pageSize);
        //构建分页构造器，传入分页参数
        IPage<Employee> Ipage = new Page(page,pageSize);
        //条件构造器，用于构造查询条件
        LambdaQueryWrapper<Employee> lambdaQueryWrapper = new LambdaQueryWrapper<>();
            //添加模糊查询条件
        lambdaQueryWrapper.likeRight(!StringUtils.isEmpty(name),Employee::getName,name);
            //添加配许条件
        lambdaQueryWrapper.orderByDesc(Employee::getName);
        //执行查询,并传入查询条件
        employeeService.page(Ipage,lambdaQueryWrapper);
    
        if(Ipage.getRecords() !=null ){
            return Result.success(Ipage);
        }
    
        return Result.error("查询失败");
    }
    ```
    

### **员工启用状态的更改**

- **需求与流程分析**
  
    在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。
    
    需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。
    
    如图示：当员工展示页面被加载到Ifream中时，会首先执行初始化钩子函数created()，调用init方法从后端获取到响应的前端数据，
    
    随后将当前用户的username记录到user中。而前端页面中会使用el-button来进行判断，如果得知当前登录的username为管理员admin，则才会开放按钮的Vue数据展示
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2023.png)
    
    前端点击进行后怎么相应给后端呢？
    
    点击按钮后，会先进入一个stattusHandle的函数中，用于进行弹窗提示。当操作者点击确认后，就调用对应的axios方法像后端发送请求。
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2024.png)
    
    考虑到此处要修改员工的状态太，后续还有修改员工的信息，所以此处我们将员工的修改操作都封装到一次进行执行。
    
    根据前端代码可以得知，此处请求的路径就是/employ，使用的put方式进行请求
    
- **代码编写**
  
    ```java
    @PutMapping
    public Result<String> updateEmploy(HttpServletRequest request,@RequestBody Employee employee){
        log.info(employee.toString());
    
        //标记更新者与更新时间,status已经保存到了employee中
        Long empID = (Long) request.getSession().getAttribute("employee");
        employee.setUpdateUser(empID);
        employee.setUpdateTime(LocalDateTime.now());
    
        //执行修改
        boolean b = employeeService.updateById(employee);
        if(b){
            return Result.success("修改成功");
        }
        return Result.error("修改失败");
    }
    ```
    
    随后执行测试，发现执行错误，不能完成数据查询。**提示我们找不到指定ID的数据**，并且**emp==null，查看错误地方进行分析。**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2025.png)
    

### **问题处理：JS精度丢失**

可以发现一个很有意思的现象，**前端传递过来的用户的ID值，与数据库中的用户ID值存在精度差异，后几位数字精度丢失。**

- **先看结论：前端的JS在处理 数字数据 时**只能保证**前16位数据的精度，而处理19位数据时，后三位会丢失精度。**
  
    首先查看数据库中Id数据，19位的Long类型数据，没有错误
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2026.png)
    
    数据库没问题，那时传递数据过程那一部分出现了问题吗？我们需要查看一下分页过程中后端响应的JSON数据。**发现后端响应时并未丢失任何的数据精度**
    
    ```jsx
    {"code":1,"msg":null
    ,"data":{"records":[
    		{**"id":1573220101411463169**,"username":"lisi","name":"里斯","password":"e10adc3949ba59abbe56e057f20f883e","phone":"13264897465","sex":"0","idNumber":"459697165481346541","status":1,"createTime":[2022,9,23,15,57,56],"updateTime":[2022,9,23,15,57,56],"createUser":1,"updateUser":1},
    		{"id":1,"username":"admin","name":"管理员","password":"e10adc3949ba59abbe56e057f20f883e","phone":"13812312312","sex":"1","idNumber":"110101199001010047","status":1,"createTime":[2021,5,6,17,20,7],"updateTime":[2021,5,10,2,24,9],"createUser":1,"updateUser":1},
    		{**"id":1572949384734920705**,"username":"wangwu","name":"王五","password":"e10adc3949ba59abbe56e057f20f883e","phone":"15369456975","sex":"1","idNumber":"412369584695123654","status":1,"createTime":[2022,9,22,22,2,12],"updateTime":[2022,9,22,22,2,12],"createUser":1,"updateUser":1}],
    "total":3,"size":10,"current":1,"orders":[],"optimizeCountSql":true,"hitCount":false,"countId":null,"maxLimit":null,"searchCount":true,"pages":1},"map":{}}
    ```
    
    响应数据没有问题，那么是什么问题，**继续排查前端页面的展示数据，发现出现了精度丢失。**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2027.png)
    
    既然响应的JSON没有丢失i精度，为什么展示时候就精度丢失了呢？
    
    原因是：**前端的javaScripot在处理任意数据时，只能保证前16位数据的精度，16位之后的数据就不能保证精度。因此在展示19位的ID值时就将后三位进行了四舍五入处理。**
    
    并且数据经过JS的处理后，保存时依然保存的失去精度的内容，所以前端保存的js对象都是失去16位以后精度的数据。
    
    验证上也很好验证，使用**alert(1572949384734920705)弹窗展示一个19位的数字，精度就丢失了，展示 1572949384734920700**
    

**问题解决：**我们可以在**服务端**给页面**响应json数据时进行处理**，**将long型数据统一转为String字符串**。

- **原理解析：**
  
    我们知道的是，对于SpringMvc而言前端控制器接收的数据都为字符串类型。如果响应java对象，并开启JSON转换后，SpringMvc可以自动将Object对象转换位JSON字符串。**而执行Object转换为JSON的就是SpringMVC提供的默认的消息转换器`MappingJackson2HttpMessageConverter`。**
    
    **如图为SpringMvc提供的默认转换器。索引的下标位置就是转换器的优先级**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2028.png)
    
    对于SpringMvc原生的消息转换器也支持通过创建自定义消息转换器，然后注册到SpringMvc中，实现自定义的类型转换。**但本次不再使用基于SpringMvc原生的创建的类型转换器来解决，而根据JackSon原生的类型转换器ObjectMapper来进行解决。**
    
    **记得自定义后将定义的消息转换器告知SpringMvc，否则SpringMvc还会用自己的默认消息转换器，而不会使用自定义的，导致不能正确转换。同时还要注意SpringMvc默认的消息转换器优先级最高，还需要将我们的消息转换器优先级在设置时提到最高。**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2029.png)
    
    **ObjectMapper类：是Jackson包下专门用于对象与Json类型转换的一个类。内部使用的是序列化Serializable的方式，将对应的java类型数据转换为JSON数据。同时也支持将JSON数据反序列化为Java对象。就使用该类进行消息转换。**
    

**我们通过继承ObjectMapper类，来自定义一些序列化器，使用序列化的方式将Long型数据转换为String，以及Date类型转为指定格式字符串。**

```java
/
*对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
*将JSON解析为Java对象的过程称为[从JSON反序列化Java对象]
 *从Java对象生成JSON的过程称为[序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {
    public static final StringDEFAULT_DATE_FORMAT= "yyyy-MM-dd";
    public static final StringDEFAULT_DATE_TIME_FORMAT= "yyyy-MM-dd HH:mm:ss";
    public static final StringDEFAULT_TIME_FORMAT= "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
//收到未知属性时不报异常
this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

//反序列化时，属性不存在的兼容处理
this.getDeserializationConfig().withoutFeatures(FAIL_ON_UNKNOWN_PROPERTIES);

SimpleModule simpleModule = new SimpleModule()
        .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
        .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
        .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

        .addSerializer(BigInteger.class, ToStringSerializer.instance)
        **.addSerializer(Long.class, ToStringSerializer.instance)**
        .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
        .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
        .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

**//注册功能模块 例如，可以添加自定义序列化器和反序列化器
this.registerModule(simpleModule);**
    }
}
```

**在SpringMvc中注册自定义的消息转换器。**

```java
@Override
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
log.info("扩展的消息转换器");
//创建消息转换器
MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter();
//将自定消息转换器传入
mappingJackson2HttpMessageConverter.setObjectMapper(new JacksonObjectMapper());

**//注册消息转换器同时，设置索引，让自己的消息转换器放在最前面，否则默认的消息转换器会在最前面，用不上我们的转换器
converters.add(0,mappingJackson2HttpMessageConverter);**
}
```

转换前的JSON字符串格式：

```json
{**"id":1573220101411463169**,"username":"lisi","name":"里斯","password":"e10adc3949ba59abbe56e057f20f883e","phone":"13264897465","sex":"0","idNumber":"459697165481346541",
"status":1,**"createTime":[2022,9,23,15,57,56],"updateTime":[2022,9,23,15,57,56]**,"createUser":1,"updateUser":1},
{"id":1,"username":"admin","name":"管理员","password":"e10adc3949ba59abbe56e057f20f883e","phone":"13812312312","sex":"1","idNumber":"110101199001010047",
"status":1,**"createTime":[2021,5,6,17,20,7],"updateTime":[2021,5,10,2,24,9],"**createUser":1,"updateUser":1},
{**"id":1572949384734920705**,"username":"wangwu","name":"王五","password":"e10adc3949ba59abbe56e057f20f883e","phone":"15369456975","sex":"1","idNumber":"412369584695123654",
"status":1,**"createTime":[2022,9,22,22,2,12],"updateTime":[2022,9,22,22,2,12],**"createUser":1,"updateUser":1}],
```

转换后的JSON字符串格式：

```json
{**"id":"1573220101411463169"**,"username":"lisi","name":"里斯","password":"e10adc3949ba59abbe56e057f20f883e","phone":"13264897465","sex":"0","idNumber":"459697165481346541",
"status":1,**"createTime":"2022-09-23 15:57:56","updateTime":"2022-09-23 15:57:56",**"createUser":"1","updateUser":"1"},
{"id":"1","username":"admin","name":"管理员","password":"e10adc3949ba59abbe56e057f20f883e","phone":"13812312312","sex":"1","idNumber":"110101199001010047",
"status":1,**"createTime":"2021-05-06 17:20:07","updateTime":"2021-05-10 02:24:09"**,"createUser":"1","updateUser":"1"},
{"**id":"1572949384734920705"**,"username":"wangwu","name":"王五","password":"e10adc3949ba59abbe56e057f20f883e","phone":"15369456975","sex":"1","idNumber":"412369584695123654",
"status":1,**"createTime":"2022-09-22 22:02:12","updateTime":"2022-09-22 22:02:12"**,"createUser":"1","updateUser":"1"}],"total":3,"size":10,"current":1,"orders":[],"optimizeCountSql":true,"hitCount":false,"countId":null,"maxLimit":null,"searchCount":true,"pages":1},"map":{}}
```

### **员工信息的编辑**

分析得知前端请求发送的地方是**/backend/page/member/add.html?id=1573220101411463169，即携带参数跳转到某个和页面。随后前端会自动执行初始化钩子函数created()将id值存入当前页面。随后调用方法自动请求/employee/1573220101411463169获取对应的数据库数据。**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2030.png)

**流程：**

1、点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]

2、在add.html页面获取url中的参数[员工id]

3、发送ajax请求，请求服务端，同时提交员工id参数

4、服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面

5、页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显

6、点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端

7、服务端接收员工信息，并进行处理，完成后给页面响应

8、页面接收到服务端响应信息后进行相应处理

**后端根据ID查询数据如下**

```java
@GetMapping("/{id}")
public Result<Employee> selectById(@PathVariable Long id){
    LambdaQueryWrapper<Employee> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.eq(null != id,Employee::getId,id);
    Employee one = employeeService.getOne(lambdaQueryWrapper);
    if(one!=null){ return Result.success(one);}
    return Result.error("员工不存在");
}
```

前端获取到数据之后会进行展示，并在我们进行修改之后点击保存，根据actionType判断是add操作还是修改操作，执行对应的js语句。进行后端数据的操作。

## 分类管理业务day03

### 公共字段自动填充

### **公共字段自动填充概念与使用**

前面我们已经完成了后台系统的员工管理功能开发，在新增员工时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工时需要设置修改时间和修改人等字段。

这些字段属于公共字段，也就是很多表中都有这些字段。如创建者create_user，修改者update_user，创建时间create_time，修改时间update_time。

**对于这些公共字段，我们也需要手动的进行自动的设定，能否进行统一处理，简化开发呢？**

**Mybatis-Plus提供了公共字段自动填充的功能，防止对公共字段的设置，进行频繁编码使得代码臃肿**

**启用步骤：**

1. 要开启Mybatis-plus的公共字段填充，**首先要在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理**，避免了重复代码。
2. **然后按照框架(Mybatis-plus)的要求编写元数据处理器，在类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口。并实现insert/updateFill()方法**

**元数据处理器触发：**当Mybatis需要进行数据的更新或者插入时，最终会将Object对象的各个字段转换为数据库中的数据。这个过程称为ORM映射。当需要将Object对象转换为数据库中数据时，**会触发元数据处理器。**

**在元数据处理器中会自动获取到，准备执行对应插入或更新操作employee对象**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2031.png)

- **代码实现**
  
    **首先在实体类上需要进行字段填充的字段上增加@TableFidle注解，并指定填充策略。**
    
    ```java
    @Data
    public class Employee implements Serializable {
        private static final long serialVersionUID = 1L;
        private Long id;
        private String username;
        private String name;
        private String password;
        private String phone;
        private String sex;
        private String idNumber;//身份证号码
        private Integer status;
    
        **@TableField(fill = FieldFill.INSERT)//插入时填充字段
        private LocalDateTime createTime;
    
        @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
        private LocalDateTime updateTime;
    
        @TableField(fill = FieldFill.INSERT)//插入时更新字符按
        private Long createUser;
    
        @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
        private Long updateUser;**
    
    }
    ```
    
    **然后创建元数据处理器，实现MetaObjectHandler接口，并重写insert/updateFill()方法**
    
    ```java
    @Component
    @Slf4j
    public class MyMetaObjectHandler implements MetaObjectHandler {
    
        /**
         * 插入操作时自动调用
         * @param metaObject
         */
        @Override
        public void insertFill(MetaObject metaObject) {
            log.info("公共字段自动填充【insert】");
            log.info(metaObject.toString());
    
            metaObject.setValue("createTime", LocalDateTime.now());
            metaObject.setValue("updateTime",LocalDateTime.now());
            metaObject.setValue("createUser",new Long(1));
            metaObject.setValue("updateUser",new Long(1));
    
        }
    
        /**
         * 更新操作自动时调用
         * @param metaObject
         */
        @Override
        public void updateFill(MetaObject metaObject) {
            log.info("公共字段自动填充【update】");
            log.info(metaObject.toString());
            metaObject.setValue("updateTime",LocalDateTime.now());
            metaObject.setValue("updateUser",new Long(1));
        }
    }
    ```
    
    **实现之后，在Mybatis执行插入或者更新操作的ORM映射将Object根据类的响应方法转换为数据库的字段时，会自动触发对应操作的元数据处理器。**
    
    但是此处有一个缺点，就是更新和插入用户时，执行操作的用户ID无法从Session中获取
    

### **使用ThreadLocal完成Session操作**

**我们首先需要明确一点，客户端发送的每次Http请求，对应的在服务器端都会分配一个新的线程来处理。**

**处理过程中涉及到下面类的方法都属于同一个线程：LoginCheckFilter的doFilter方法—》EmployeeController的update方法—》MyMetaObjectHandler的updateFill方法**

可以在上面的三个方法中分别加入使用**线程获取ID**的操作：**`long id= Thread.currentThread.getId()`**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2032.png)

- **ThreadLocal**
  
    ThreadLocal并不是一个Thread，而是一个Thread的局部变量。**当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个的可以独立的改变自己的副本，而不会影响其他线程所对应的副本。**
    
    **ThreadLocal为每一个线程提供单独一份存储空间，具有线程隔离效果。**只有在线程内才能获取到对应的值，线程外不能进行访问。
    
    **常用方法：**
    
    **`public void set(T value)`** 设置当前线程的局部变量的值
    
    **`public T get()`**                 返回当前线程所对应的线程局部类变量的值
    

**使用思想：**在最开始访问页面的拦截器/过滤器Filter中，**将Session的ID值存入线程的ThreadLocal变量中，然后在其它地方调用Thread的ThreadLocal变量**，直接获取到操作用户的ID值。此处我们在LoginCheckFilter中设置ThreadLocal变量值进行存储。

**首先**编写BaseContext工具类，基于ThreadLocal封装的工具类

```java
/**
* 基于ThreadLocal封装的工具类，用于保存和获取当前登录用户的ID
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal =new ThreadLocal<>();

    public static void setCurrentId(Long id){
        threadLocal.set(id);
    }
    public Long getCurrentId(){
        return threadLocal.get();
    }
}
```

然后使用我们封装的ThreadLocal工具类进行数据的获取。

### **新增分类(新功能)**

- **需求分析**
  
    **后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类。**当我们在后台系统中添加菜品时需要选择一个菜品分类，当我们在后台系统中添加一个套餐时需要选择一个套餐分类，在移动端也会按照菜品分类和套餐分类来展示对应的菜品和套餐。
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2033.png)
    
    **数据模型：category表字段以及唯一约束。主要操作的字段就是type以及name**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2034.png)
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2035.png)
    

## **MybatisPlus中使用Mybatis**

通过查看源码可以得知，MybatisPlus提供了**IService<T>接口，用于提供一系列的MybatisPlus提供的方法的规范。**等同于我们自动定义的XXXService。

还提供了一个**ServiceImpl<M,T>的类内部自动实现了IService<T>接口中的方法**，同时还自动的将XXXMapper使用变量自动注入到了ServiceImpl<M,T>类的**BaseMapper变量中。**

经过测试发现，如果我们按照基础的Mybatis思想，创建XXXMapper.xml，XXXMapper接口，并创建指定的自定义Statement方法。

并在按照Mybatis-plus低代码思想下XXXService继承IService<T>接口，XXXServiceImpl继承ServiceImpl<M,T>实现类的情况下，调用我们自定义的方法，依然有效。

- **详细代码：**
  
    **原始Mybatis的XML与接口**
    
    这里的resultType实体类别名，是在yml配置中配置typealias包完成的，否则还是必须使用全限定名
    
    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper
            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.reggie.mapper.CategoryMapper">
    
        <select id="MySelectOneById" resultType="category">
            select * from category where id =#{id};
        </select>
    
    </mapper>
    ```
    
    ```java
    public interface CategoryMapper **extends BaseMapper<Category> {**
        Category MySelectOneById(Long id);
    }
    ```
    
    **Mybatis-plus下的Service接口与接口实现类impl**
    
    ```java
    public interface CategoryService **extends IService<Category>** {
        Category MySelectOnById(Long id);
    }
    ```
    
    ```java
    @Service
    @Slf4j
    public class CategoryServiceImpl **extends ServiceImpl<CategoryMapper, Category> implements CategoryService** {
    		// @Autowired
        // CategoryMapper categoryMapper;
    
    		@Override
        public Category MySelectOnById(Long id) {
    				//Category category = categoryMapper.MySelectOneById(id);
            Category category = baseMapper.MySelectOneById(id);
            return category;
        }
    }
    ```
    
    **经过测试，baseMapper与categoryMapper是同一个对象。**
    

XXXServiceimpl执行时必须调用Mapper的实例对象，才能调用Mybatis操作数据库。而Mapper接口需要被实例化为对象才可以调用。

在我们原生的Mybatis中需要SqlSessionFactory创建sqlSession并生成Mapper对象，这个过程会自动的检查XXXMapper.xml文件的namespace。

而MybatisPlus提供给我们的是BaseMapper<T>，并且内部SqlSessionFactory自动注入并自动生成SqlsessionFactory，同时也会自动生成XXXMapper对象。

**个人猜测MybatisPlus在原生没有Mapper.xml时，根据BaseMapper<T>接口中的方法，自动创建了一个XXXMapper.xml文件。并依赖于此文件进行mapper对象的创建**

**当加入了自定义的Mapper.xml后，会根据继承了BaseMapper<T>的XXXMapper接口下的方法，同时将我们自定义的xml和对应方法加入Mapper实现类中。自动完成合并。**

**测试代码：**

```java
@SpringBootTest
@Slf4j
public class CateGoryServiceTest {
    @Autowired
    CategoryService categoryService;

    @Test
    //测试Mybatis中自定操作是否生效
    public void testMybatis(){
        Long id = 0L;
        Category category = categoryService.MySelectOnById(id);
        log.info("查询数据{}",category);
    }

    @Test
    public void testMybatis_plus(){
        Long id = 0L;
        Category one = categoryService.getOne(new LambdaQueryWrapper<Category>().eq(Category::getId, id));
        log.info("Mybatis-plus对象：{}",one);
    }
}
```

经测试验证猜想基本无误，但使用Debuge时并未进入mybatis_plus核心源码查看。因此不是绝对肯定。

- **代码编写**
  
    **创建Category实现类，CateGroyMapper接口，CateGroyService接口，CategroyServiceImpl接口，CategoryController控制器**
    
    在开发代码之前，需要梳理一下整个程序的执行过程:
    
    1、页面(backend/page/category/list.html)发送ajax请求，将新增分类窗口输入的数据以json形式提交到服务端
    
    2、服务端Controller接收页面提交的数据并调用Service将数据进行保存
    
    3、Service调用Mapper操作数据库，保存数据
    
    可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的json数据结构相同，所以服务端只需要提供一个方法统一处理即可
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2036.png)
    
    ```java
    @PostMapping
    public Result<String> addCategory(@RequestBody Category category) throws Exception{
    	
    		boolean save = categoryService.save(category);
        if(save){
            return Result.success("分类添加成功");
        }else {
            return Result.error("分类添加失败");
        }
    }
    ```
    
    此处由于数据库对于name字段设置了唯一约束，因此在插入name相同的数据时，会报数据库的操作异常。
    
    这个异常抛出即可，我们在GolbalException的全局异常处理器中已经对这个一场进行了处理，会自动的调用异常处理器进行解决
    

### 分页展示与**修改删除分类**

- **代码编写**
  
    ```java
    //分类的分页查询
    @GetMapping("/page")
    public Result<IPage> selectAllAndPagination(int page,int pageSize){
        IPage<Category> Ipage = new Page<>(page,pageSize);
        //创建一个条件构造器用于分类的排序
        LambdaQueryWrapper<Category> wrapper = new LambdaQueryWrapper<>();
        wrapper.orderBy(true,true,Category::getSort);
        categoryService.page(Ipage,wrapper);
        if(Ipage.getRecords()!=null){
            return Result.success(Ipage);
        }
        //查询失败，大概率服务器访问数据库出现了问题
        return Result.error("操作有误请重新查询");
    }
    
    //修改分类信息
    @PutMapping
    public Result<String> updateCategory(@RequestBody Category category){
        boolean b = categoryService.updateById(category);
        if(b){
            return Result.success("修改成功");
        }
        return Result.error("修改失败");
    }
    
    //删除分类信息
    @DeleteMapping
    public Result<String> deleteCategory(Long ids){
        //boolean b = categoryService.removeById(ids);
        boolean b = categoryService.remove(ids);
        if(b){
            return Result.success("删除成功");
        }
        return Result.error("删除失败");
    }
    ```
    
- **功能完善**
  
    在进行套餐的分类以及菜品的分类时，我们并没有考虑到一个问题，就是当一个菜品分类被删除后，这个分类下保存的具体菜品信息。
    
    针对这个问题，我们需要结合数据库以及一些后端的操作进行处理。
    
    首先就是建立各类菜品的数据库Dish，以及套餐的菜品Setmeal。同步创建实体类
    
    同时创建Mapper接口DishMapper，SetmealMapper。Service接口实现类DishService，DishServiceimpl，SetmealService，SetmealServiceimpl
    
    为了保证删除分类时，当分类下有具体菜品时的不误删，因此需要引入判断机制。
    
    category是进行分类操作的**，我们只需要跟Mybatis一样在CategoryService中编写一个remove删除方法，**用于判断分类下是否有菜品**，有的话不删除，并提示有菜品，无法删除**
    
    ```java
    @Override
    public boolean remove(Long id) {
        //检查当前分类是否关联了菜品，如果关联，抛出一个业务异常
        LambdaQueryWrapper<Dish> dishWrapper = new LambdaQueryWrapper<>();
        dishWrapper.eq(Dish::getCategoryId,id);
        int dishCount = dishService.count(dishWrapper);
        **if(dishCount!=0){
            //关联有菜品，抛出业务异常
            throw new CustomException("当前分类下关联了菜品，不能删除");
        }**
        //检查当前分类是否关联了套餐菜品，如果已经关联，抛出一个业务异常
        LambdaQueryWrapper<Setmeal> setmealWrapper = new LambdaQueryWrapper<>();
        setmealWrapper.eq(Setmeal::getCategoryId,id);
        int setmealCount = setmealService.count(setmealWrapper);
        **if(setmealCount!=0){
            //套餐关联有菜品，抛出业务异常
            throw new CustomException("当前套餐下关联了菜品，不能删除");
        }**
        //正常删除分类
        // int i = baseMapper.deleteById(id);
        return super.removeById(id);
    }
    ```
    
    此时我们将这个提示放到异常中进行处理，新建一个异常类，并创建指定的异常处理器进行异常的处理
    
    ```java
    public class CustomException extends RuntimeException{
        public CustomException(String message){
            super(message);
        }
    }
    ```
    
    ```java
    @ExceptionHandler(CustomException.class)
    public Result<String> doCustomException(CustomException ex){
        log.info(ex.getMessage());
        return Result.error(ex.getMessage());
    }
    ```
    

## **菜品管理业务day04**

### 文件上传下载**(重点)**

- **上传下载介绍**
  
    **前端上传：**
    
    文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。
    
    文件上传时，对页面的form表单有如下要求:
    
    - method="post"　采用post方式提交数据
    - enctype="multipart/form-data"　采用multipart格式上传文件
    - type="file"　使用input的file控件上传
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2037.png)
    
    目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传。**例如ElementUI中提供的upload上传组件:**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2038.png)
    
    **文件上传的后端编码：**
    
    服务端要接收客户端页面上传的文件，**通常都会使用Apache的两个组件：commons-fileupload  和 commons-io**
    
    **由于使用Apache原生的两个组件上传文件操作繁琐，所以Spring框架`在spring-web包中对文件上传进行了封装，大大简化了服务端代码。**
    
    **SpringMVC接收到的MultipartFile时，会将源文件更名自动的生成一个.tmp的临时文件在服务器。必须要手动进行转存，否则方法结束文件就会自动消失。**
    
    **我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件。**
    
    ```java
    @PosttMapping("/quick16")
    @ResponseBody
    public void test20(String name, MultipartFile uploadFile) throws IOException {
        **//getOriginalFilename方法获得上传文件的名称14111.obg
        String originalFilename = multipartFile.getOriginalFilename();
    		~~//获取ServletContext对象
        ServletContext servletContext = session.getServletContext();
        //获取当前工程文件的真实路径
        String photoRealPath = servletContext.getRealPath("originalFilename");
    		//创建文件对象
    		File photoFile = new File(photoRealPath);
    		//判断文件对象是否存在
    		if(!file.exists()){
               file.mkdir();//创建文件
           }
       //设定上传的位置,文件的保存路径+分隔符+文件的名称
       String finalPath = photoRealPath+ File.separator+originalFilename;~~
    		//保存文件，并指定文件的上传路径
        multipartFile.transferTo(new File("G:/"+originalFilename));**
        System.out.println(name);
        System.out.println(uploadFile);
    }
    ```
    
    **文件下载**
    
    文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程。通过浏览器进行文件下载，通常有两种表现形式:
    
    - **以附件形式下载，弹出保存对话框**，将文件保存到指定磁盘目录
    - **直接在浏览器中打开，直接展示图片效果**
    
    **通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程。**
    
- **前端源码分析**
  
    **文件上传：**
    
    简单分析，文件上传功能已经进行了专门的拆分，**页面端可以使用ElementuI提供的上传组件，可以直接使用资料中提供的上传页面。**位置:资料/文件上传下载页面/upload.html
    
    分析一下ElementUI的源码，发现当选择图片提交后请求的是/common/upload，那么此时就可以进行前端源码分析了。
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2039.png)
    
    由前端源码得知，ElementUI会自动生成一个file类型的input表单，并且固定了**name=file。选择文件并**点击上传之后，会自动的请求**/common/upload**地址，传递给后端。
    
    具体的请求内容可以看到，**为binary表示二进制。点击查看详细后，可以看到文件名filename以及上传时input中指定的name。**
    
    **文件下载：**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2040.png)
    
    有源码分析可知，文件上传完成之后，会自动调用**handleAvatarSuccess**方法，请求对应路径以获取图片。
    
    图片的名称是根据上传之后后端响应的JSON内容来获取的。前端的展示是通过**img标签**展示的，内置了一个判断，当**imageUrl**有值后img标签求开启了。
    
    **img标签会自动的发送请求到服务端来获取图片。请求地址就变为了/common/download?name=文件名**
    
- **后端代码实现**
  
    **上传文件：**
    
    文件不仅要被后端接收，同时我们还要转存文件到指定的位置，为了保证存放位置灵活性，**可以直接在yml中进行设置。然后注入到对应的参数中进行获取。**
    
    ```yaml
    reggie:
      path: G:\Code WorkSpace\Reggie\
    ```
    
    **后端编码，可以使用royi文件上传框架，比较严谨**
    
    ```java
    @Value("${reggie.path}")
    private String basepath;
    
    @PostMapping("/upload")
    public Result<String> upload(MultipartFile file){
        //获取文件原始文件名,带文件后缀
        String originalFilename = file.getOriginalFilename();
    
        // **获取**去除后缀的文件名,和**文件后缀**
        ~~// String prefixFilename = originalFilename.substring(0, originalFilename.lastIndexOf("."));~~
        String suffixFilename = originalFilename.substring(originalFilename.lastIndexOf("."));
        //使用UUID生成文件名后缀，防止文件名重名造成文件覆盖。
        String filename = UUID.randomUUID().toString()+suffixFilename;
    
        //判断文件夹是否存在，如果不存在新建一个文件夹,
        File file1 = new File(basepath);
        if(!file1.exists()){
            //如果多级目录都不存在，则一并创建
            file1.mkdirs();
        }
    
        try {
            //将临时文件转存到硬盘中
            file.transferTo(new File(basepath + filename));
            return Result.success(filename);
        } catch (IOException e) {
            e.printStackTrace();
            return Result.error("未知错误，上传失败");
        }
    }
    ```
    
    **文件下载：**
    
    img标签会自动地访问服务端请求图片。为了保证后端数据的安全，我们不采用直接展示的形式，而使用流的方式将后端的图片内容相应到前端。
    
    ```java
    @GetMapping("/download")
    public void download(HttpServletResponse response, String name){
        File file = new File(basepath + name);
        try {
    				//使用输入流从硬盘中获取到文件信息
    				FileInputStream fileInputStream = new FileInputStream(file);
    				//创建一个输出流响应流数据到前端，在前端展示图片
    				ServletOutputStream outputStream = response.getOutputStream();
    				
    				//使用数组做缓存，将流写入到前端。
    				int len = 0;
    				byte[] bytes = new byte[1024];
    				while((len = fileInputStream.read(bytes))!=-1){
    				    outputStream.write(bytes);
    				    outputStream.flush();
    				}
    				outputStream.close();
    				fileInputStream.close();
    		} catch (Exception e) {
    				e.printStackTrace();
    		}
    }
    ```
    

### **新增菜品(DTO)**

在开发代码之前，需要梳理一下新增菜品时**前端页面和服务端的交互过程:**

1、页面**(backend/page/food/add.html)**发送ajax请求，请求服务端获取菜品分类数据**/category/list?type=1**并展示到下拉框中

2、页面发送请求进行图片上传，请求服务端**/common/upload**将图片保存到服务器，并响应回图片名称

3、页面发送请求进行图片下载，请求**/common/download**将上传的图片进行回显

4、点击保存按钮，发送ajax请求**/dish**，将菜品相关数据以json形式提交到服务端

开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可。

新增菜品的请求是发往**/dish，并且请求的JSON串格式较为复杂**

```json
{"name":"asdasd","price":45600,"code":"","image":"5e330ebf-146d-4d47-9b64-ef9f84ef7365.jpeg",
"description":"dsadadsasd","status":1,"categoryId":"1397844391040167938",
**"flavors":[{"name":"忌口","value":"[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]",**
"showOption":false}]}
```

其中涉及一个新的菜品口味表DishFlavors。创建dishflavor实体类，DishflavorMapper接口，DishFlavorService，DishFlavorServiceImpl。

**但是对于MybatisPlus而言，不能处理一对多的数据，若将flavor对象保存到Dish也可以，但是造成了较强的侵入性。因此引入了DTO将Flavor封装到其中**

**DTO：全称为Data Transfer Object，即数据传输对象，一般用于展示层与服务层之间的数据传输  。**[浅析VO、DTO、DO、PO的概念、区别和用处](https://blog.csdn.net/zjrbiancheng/article/details/6253232)

```java
@Data
public class DishDto extends Dish {
    private List<DishFlavor> flavors = new ArrayList<>();

    private String categoryName;
    private Integer copies;
}
```

新增菜品时，需要将菜品添加到Dish中之外，还需要根据Dish的id值，在dish_flavor中保存flavors口味信息。我们直接将添加菜品逻辑操作封装到dishService中

```java
@Override
**@Transactional**
public boolean addDish(DishDto dishDto) {
    // 保存菜品信息
    boolean save = this.save(dishDto);
    if(save){
        //保存菜品的口味
        Long dishId = dishDto.getId();
        // 获取菜品口味集合
        List<DishFlavor> flavors = dishDto.getFlavors();
        // 同时将DishID设置到每一个口味数据中
        flavors = flavors.stream().map(item -> {
            item.setDishId(dishId);
            return item;
        }).collect(Collectors.toList());
        // 执行保存菜品口味操作
        return dishFlavorService.saveBatch(flavors);
    }
    return false;
}
```

新增菜品涉及多项表操作，需要开启事务，并**在SPringMVCConfig上开启事务支持**添加`@EnableTransactionManagement`注解

### **菜品信息分页**

首先查看一下前端进行上传操作的的源码信息，可以看到明显的调用了两个方法。限制了登录的检查，以及图片格式以及大小的限定

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2041.png)

首先在访问菜品分类页面时候，会发送Get请求直接访问**/dish/page?page=1&pageSize=10**，自动查询所有的菜品，并自动做分页处理。那么首先就实现该功能

图片的展示是通过上传下载功能实现的

**代码实现：**

```java
@GetMapping("/page")
public Result<IPage> seectAllAndPagination(int page,int pageSize,String name){
    IPage<Dish> dishPage = new Page<>(page, pageSize);
    // 设置条件构造器
    LambdaQueryWrapper<Dish> dishWrapper = new LambdaQueryWrapper<>();
        //当传入的name不为空，则执行模糊查询
    dishWrapper.like(name!=null,Dish::getName,name);
        //以插入时间为基准进行排序
    dishWrapper.orderBy(true,true,Dish::getUpdateTime);
    dishService.page(dishPage,dishWrapper);

    if(dishPage.getRecords()!=null){
        return Result.success(dishPage);
    }
    return Result.error("未知错误请稍后再试");
}
```

同时注意到一件事情，前端展示分类时需要一个`categoryName`的参数，但是此参数如果只将Dish的分页信息发送到前端并不能查看到。因为查询到的Dish数据中并不包含分类名称categoryName的信息。**因此需要二次查询数据库进行数据的封装。**

首先将查询的数据对象由Dish换为保存categoryName信息的DishDto数据，分页查询到的DIsh并没有该属性，因此需要Dish拷贝到DishDto中进行数据的封装。

**数据拷贝使用Spring的BeanUtils.copyProperties(Object source,Object target)。可以将source对象中的所有属性复制到target对象中**

```java
@Autowired
CategoryService categoryService;
@GetMapping("/page")
public Result<Page> selctAllAndPagination(int page, int pageSize, String name){
		//分页查询需要的DIsh
	  IPage<Dish> dishPage = new Page<>(page, pageSize);
	  // 设置条件构造器
	  LambdaQueryWrapper<Dish> dishWrapper = new LambdaQueryWrapper<>();
	      //当传入的name不为空，则执行模糊查询
	  dishWrapper.like(name!=null,Dish::getName,name);
	      //以插入时间为基准进行排序
	  dishWrapper.orderBy(true,true,Dish::getUpdateTime);
	  dishService.page(dishPage,dishWrapper);

	  //根据需要的Dish集合，转换为对应的DishDto
	  List<Dish> dishList = dishPage.getRecords();
	  //由于DIsh的数据信息已经查询好并排好序了，因此获取到的DishDto也是同样的顺序。
	  **//根基Dish数组中每一个Dish的信息，获取到对应的DIshDto对象
	  List<DishDto> dishDtos = dishList.stream().map(dish -> {
	      DishDto dishDto = new DishDto();
	      BeanUtils.copyProperties(dish, dishDto);
	      //根据Dish中的catetoryID获取到Category对象
	      Category category = categoryService.getById(dish.getCategoryId());
	      dishDto.setCategoryName(category.getName());
	      return dishDto;
	  }).collect(Collectors.toList());**
	
	  //将categoryName数据获取到封装到分页对象中
	  Page<DishDto> dishDtoPage = new Page<>();
	      //拷贝DishPage的数据到DishDtoPage中，但不拷贝records
	  BeanUtils.copyProperties(dishPage,dishDtoPage,"records");
		
	  dishDtoPage.setRecords(dishDtos);
	  if(dishPage.getRecords()!=null){
	      return Result.success(dishDtoPage);
	  }
	  return Result.error("未知错误请稍后再试");
}
```

最后将DishDto数据响应回前端

### 循环依赖(重点)

[和循环依赖说再见！](https://zhuanlan.zhihu.com/p/534885204)

问题出现：想要分离DishController的逻辑。在DishService层中引入了CategoryService依赖。但是由于CategoryService中也引入了DishService依赖。

就导致了DishService依赖—》CategoryService。但CategoryService也依赖—》DishService。

**在执行DishService的Bean创建过程的依赖注入环节，DishService需要CategoryService的Bean对象。于是去创建CategoryService的Bean对象，但是发现CategoryService对象中又需要DishService的Bean对象，于是都不能创建成功。出现死循环**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2042.png)

**循环依赖场景**

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2043.png)

使用缓存解决循环依赖问题

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2044.png)

![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2045.png)

- **代码示例：**
  
    **1-DIshService中注入CategoryService依赖**
    
    ```java
    @Service
    **public class DishServiceImpl** extends ServiceImpl<DishMapper, Dish> implements DishService {
    
        @Autowired
        DishFlavorService dishFlavorService;
    		
    		**@Autowired
    		CategoryService categoryService;**
    		/**
    	   *将List<Dish>转换为List<DishDto>
    	   */
    		@Override
        public List<DishDto> transferDishToDishDto(List<Dish> dishList) {
    				//根基Dish数组中每一个Dish的信息，获取到对应的DIshDto对象
    				List<DishDto> dishDtos = dishList.stream().map(dish -> {
                DishDto dishDto = new DishDto();
                BeanUtils.copyProperties(dish, dishDto);
    						//根据Dish中的catetoryID获取到Category对象
    						Category category = categoryService.getById(dish.getCategoryId());
                dishDto.setCategoryName(category.getName());
                return dishDto;
            }).collect(Collectors.toList());
            return dishDtos;
        }
    }
    ```
    
    **2-CategoryService中注入DishSertvice依赖**
    
    ```java
    @Service
    @Slf4j
    public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {
    
        **@Autowired
        private DishService dishService;**
        @Autowired
        private SetmealService setmealService;
    
        /**
         * 根据ID删除分类，删除之前检查分类下是否有菜品
         * @param id
         */
        @Override
        public boolean remove(Long id) {
            //检查当前分类是否关联了菜品，如果关联，抛出一个业务异常
            LambdaQueryWrapper<Dish> dishWrapper = new LambdaQueryWrapper<>();
            dishWrapper.eq(Dish::getCategoryId,id);
            **int dishCount = dishService.count(dishWrapper);**
            if(dishCount!=0){
                //关联有菜品，抛出业务异常
                throw new CustomException("当前分类下关联了菜品，不能删除");
            }
            //检查当前分类是否关联了套餐菜品，如果已经关联，抛出一个业务异常
            LambdaQueryWrapper<Setmeal> setmealWrapper = new LambdaQueryWrapper<>();
            setmealWrapper.eq(Setmeal::getCategoryId,id);
            int setmealCount = setmealService.count(setmealWrapper);
            if(setmealCount!=0){
                //套餐关联有菜品，抛出业务异常
                throw new CustomException("当前套餐下关联了菜品，不能删除");
            }
            //正常删除分类
            // int i = baseMapper.deleteById(id);
            return super.removeById(id);
        }
    ```
    

### **修改菜品**

- **首先分析前端新增代码：**
  
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2046.png)
    
    当点击修改按钮之后，会调用addFoodType()函数，并将当前行的Dish的id传递过去。
    
    修后函数内会自动调用menuHandle()请求页面add.list，将挖空部分替换为add.html的页面。
    
    在add.html的初始方法处，会获取默认的菜品的分类数据，以及默认的口味的Json数据。
    
    同时还将ID的值从URL上分离下来，同时跟据是否存在ID值，设置页面状态为edit编辑还是add添加
    
    如果有ID值就自动调用init方法，调用queryDishById从后端获取数据，并获取图片内容。查看queryDishById()可知,请求地址是**/dish/${id}，方式为GET**
    
    根据返回内容可以得知，返回的对象为包含口味flavors的DishDto
    
    **以上为点击编辑按钮后的所有逻辑**
    
    对于保存功能，点击后请求地址为/dish，请求方式为PUT
    
    前端请求发送到后端后封装为DishDto对象，但是DishDto不能直接进行更新。
    
    首先根基DishDto中的Dish数据更新Dish。然后再将DIshDto传输到DishFlavors中，根据DIshID删除原有的flavors，再插入新的Flavors
    
- **后端代码编写**
  
    **前端点击修改页面后，获取DIshDto信息的逻辑代码**
    
    **DishController代码**
    
    ```java
    //根据ID查询到封装有DIsh和flavors的DIshDto信息
    @GetMapping("/{id}")
    public Result<DishDto> getDish(@PathVariable Long id){
        //根据DIsh的ID值获取到对应的DishDto对象
        DishDto dishDto = dishService.getFlavorsByDishId(id);
    
        //根据Dish中的CategoryID获取CategoryName分类名称
        Category category = categoryService.getById(dishDto.getCategoryId());
        dishDto.setCategoryName(category.getName());
    
        return Result.success(dishDto);
    }
    ```
    
    **DishService的逻辑操作**
    
    ```java
    //根据Dish ID值获取DishFlavors并封装为DishDto
    @Override
    @Transactional
    public DishDto getFlavorsByDishId(Long id) {
    		//获取DIsh数据并保存到DishDto中
    		Dish dish = this.getById(id);
        DishDto dishDto = new DishDto();
        BeanUtils.copyProperties(dish,dishDto);
    
    		//根据DIsh的Id值查询Dish的口味信息
    		LambdaQueryWrapper<DishFlavor> dishFlavorWrapper = new LambdaQueryWrapper<>();
        dishFlavorWrapper.eq(id!=null,DishFlavor::getDishId,id);
        List<DishFlavor> flavors = dishFlavorService.list(dishFlavorWrapper);
    
    		//将查询到的DishFlavors口味信息放入到DishDto中
    		dishDto.setFlavors(flavors);
        return dishDto;
    }
    ```
    
    **前端进行修改，点击保存后发送的数据**
    
    **JSON数据：**
    
    ```json
    {"id":"1397850140982161409","name":"毛氏红烧肉","categoryId":"1397844263642378242","price":6800,"code":"123412341234","image":"0a3b3288-3446-4420-bbff-f263d0c02d8e.jpg",
    "description":"毛氏红烧肉毛氏红烧肉，确定不来一份？","status":1,"sort":0,"createTime":"2021-05-27 09:40:19","createUser":"1","updateUser":"1","isDeleted":0,
    **"flavors":[
    			{"id":"1397850141015715841","dishId":"1397850140982161409","name":"忌口","value":"[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]","createTime":"2021-05-27 09:40:19","updateTime":"2021-05-27 09:40:19","createUser":"1","updateUser":"1","isDeleted":0,"showOption":false},
    			{"id":"1397850141040881665","dishId":"1397850140982161409","name":"辣度","value":"[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]","createTime":"2021-05-27 09:40:19","updateTime":"2021-05-27 09:40:19","createUser":"1","updateUser":"1","isDeleted":0,"showOption":false},
    			{"name":"甜味","value":"[\"无糖\",\"少糖\",\"半糖\",\"多糖\",\"全糖\"]","showOption":false}
    ],**
    "categoryName":"湘菜","copies":null}
    ```
    
    **Controller操作：**
    
    ```java
    //更新菜品信息，同时更新口味信息
    @PutMapping
    public Result<String> updateDish(@RequestBody DishDto dishDto){
        boolean b = dishService.updateDish(dishDto);
        if(b){
            return Result.success("菜品更新成功");
        }
        return Result.error("更新失败，请稍后再试");
    }
    ```
    
    **DishService：**
    
    ```java
    //更新Dish信息以及对应的Dish口味信息
    @Override
    @Transactional
    public boolean updateDish(DishDto dishDto) {
    //更新Dish信息
    boolean b = this.updateById(dishDto);
    //Dish内容更新成功后，更新DIsh对应的口味信息
    if(b){
    				//清除原来的Dish口味信息
    				LambdaQueryWrapper<DishFlavor> dishFlavorWrapper = new LambdaQueryWrapper<>();
            dishFlavorWrapper.eq(DishFlavor::getDishId,dishDto.getId());
            dishFlavorService.remove(dishFlavorWrapper);
    
    				//插入新的DishFlavors信息
    				return dishFlavorService.addFlavorsByDishId(dishDto);
        }
        return false;
    }
    ```
    

### **菜品的起停售和菜品的删除**

- **首先根据前端的代码分析：**
  
    最基础的是ElementUI的操作，当选中多行数据前的复选框之后，会自动将数据封装到ElementUI自带的tableData数组中。tableData数组中的数据格式就是每行数据的行数据信息.具体可以参照ElementUI的官网信息[组件 | Element](https://element.eleme.cn/#/zh-CN/component/table)
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2047.png)
    
    当数据选中后，封装tabledata的同时，还会调用HandleSelectionChange(tableData)，自动传入talbeData对象。在此方法中，进行数据处理，将tableData中的每一行数据的id信息获取出来存放到checkList数组中。**也就是说checkList中存放的就是要进行处理的ID数组信息。由于使用的是`check.join(",")`，则将js对象转换为了一个字符串。格式如下**
    
    ```java
    ids=1397849739276890114,1397850392090947585,1397850851245600769,1397851099502260226
    ```
    
    **随后点击批量操作之后就调用对应的**`deleteHandle`**方法，将前端数据传递到后端。其他批量操作同理**
    
    ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2048.png)
    
    分析删除操作，发现批量删除与删除操作使用的同一个方法，仅仅是进行状态的判断，因此可以进行通用。
    
- **后端逻辑编写**
  
    **首先将前端传递的String类型的ids数组进行处理**
    
    ```java
    //将String数组转换为List<Long>
    private ArrayList<Long> parseStrsToLongList(String ids) {
        String[] split = ids.split(",");
        ArrayList<Long> idss = new ArrayList<>();
        for (String s : split) {
            Long dishId = Long.valueOf(s);
            idss.add(dishId);
        }
        return idss;
    }
    ```
    
    - **删除操作代码：**
      
        删除操作是以Delete方式请求的地址为**/dish的后端方法**
        
        Controller操作：
        
        ```java
        //根据传入DishIds数组删除DIsh信息以及对应的Flavor信息
        @DeleteMapping
        public Result<String> deleteDish(String ids){
            log.info("数据格式",ids);
        		//转换String的id数组为List<Long>
            ArrayList<Long> idss = parseStrsToLongList(ids);
            boolean b = dishService.deleteDishByIds(idss);
            if(b){
                return Result.success("批量删除成功");
            }
            return Result.error("未知错误，批量删除失败");
        }
        ```
        
        DishService:
        
        ```java
        //根据DIshId数组批量删除DIshId
        @Override
        @Transactional
        public boolean deleteDishByIds(List<Long> dishIds){
            // 根绝DIshids批量删除Dish
            boolean b = this.removeByIds(dishIds);
            if(b){
                // 获取DIshid数据，并批量删除Dishd对应的Flavors
                for (Long dishId : dishIds) {
                    dishFlavorService.deleteFloversByDishId(dishId);
                }
                return true;
            }
            return false;
        }
        ```
        
        DishFlavorsService：
        
        ```java
        //根据单个DishId删除对应的dishFlavors
        @Override
        public boolean deleteFloversByDishId(Long DishId) {
        	  //根据DIshid删除flovers口味信息
        	  LambdaQueryWrapper<DishFlavor> dishFlavorWrapper = new LambdaQueryWrapper<>();
        	  dishFlavorWrapper.eq(DishFlavor::getDishId,DishId);
        	  boolean remove = this.remove(dishFlavorWrapper);
        	  return remove;
        }
        ```
        
    - **停启售操作代码：**
      
        ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2049.png)
        
        前端传递的数据封装到了`dishState`模型中，然后发送请求交给了js的dishStatusByStatus方法。
        
        传递时status使用了URL传递，而id保存到了ids中进行传递。**请求地址为/dish/status/{status}**
        
        Controller层操作：
        
        ```java
        //根据传入的ID更新
        @PostMapping("/status/{status}")
        public Result<String> updateDishStatus(String ids,@PathVariable Integer status){
        // log.info("数据展示：{}",ids);
            // log.info("状态：{}",status);
        ArrayList<Long> dishIds = parseStrsToLongList(ids);
            boolean b = dishService.updateDishStatus(dishIds, status);
            if(b){
                return Result.success("售卖状态修改成功");
            }
            return Result.error("售卖状态修改失败");
        }
        ```
        
        DishService操作：
        
        ```java
        //根据前端传递的DishIds数组以及status更新DIsh的状态
        @Override
        public boolean updateDishStatus(List<Long> dishIds,Integer status) {
        		//根据DishIds查询到所有的Dish并重设status
        		List<Dish> dishList = this.listByIds(dishIds);
        		//重设每一个DIsh的status值
        		dishList = dishList.stream().map(dish -> {
        		    dish.setStatus(status);
        		    return dish;
        		}).collect(Collectors.toList());
        		//更新Dish的status信息
        		// return this.updateBatchById(dishList);
        		return this.updateBatchById(dishList);
        }
        ```
        

## **套餐管理业务day05**

### 新增套餐(前端复杂)

- **前端代码分析：**
  
    首先是进入到**/page/cmbo/list.html**的页面，该页面为套餐的展示页面，根据展示页面可以查看到**/page/cmbo/add.html为套餐的新增页面**
    
    - **进入页面就自动执行的操作**
      
        ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2050.png)
        
        查看新增页面源码，根据Vue初始化方法created()，首先会调用`getDishTypeList()`并间接调用*`etCategoryList`*方法，发送Get请求category/list?type=2&page=1&pageSize=1000，来获取套餐分类信息，并存入`**setMealList**`中。
        
        随后还会调用`getDishType()`并间接调用*`getCategoryList`*方法发送Get请求**/category/list?type=1，**来获取到所有的菜品分类信息并存入`**dishType**`中。**category/list?type=1/2的操作，在**CategoryController中已经实现了，是之前菜品分类查询的操作。
        
        同时在获取到所有菜品分类信息，存入`**dishType**`后。自动检索处第一个菜品分类下，是否有具体的菜品信息，即发送**/dish/list?categoryId=1397844263642378242。查询该菜品分类下的所有菜品信息**。同时处理获取的所有菜品信息，并加入`dishId`以及`dishName`属性后将所有菜品信息封装到`**dishaddList**`中
        
    - **点击添加菜品按钮后的逻辑**
      
        当点击了添加菜品的功能后，会自动的调用`openAddDish`方法，跳出弹窗。并从先前查询出来的菜品分类保存的**DishType**中展示分类中排在第一位的数据，用于直接的展示。
        
        在弹窗的页面，中如果在搜索框输入搜索数据则会将值赋值到**`value`**中，当点击查询后就修改**`searckkey`**值为**`value`**。同时加入了钩子函数**`watch`**监听`**seachKey**`数值变化，当发现重新赋值后，就执行对应的方法`seachKey(value)`方法。并在内部请求`getDishForName(searckKey)`。用于从后端获取Dish数组。
        
        ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2051.png)
        
        如果选中根据分类查询到具体的菜品信息时，会调用`checkedListHandle()`方法将选中的菜品的所有信息，保存到**`checkList`**中，选中多个就保存菜品信息数组
        
        ```java
        **categoryId: "1397844263642378242",code: "222222222",**copies: 1,**createTime: "2021-05-27 09:38:43",updateUser: "1",createUser: "1",description: "来自鲜嫩美味的小鸡，值得一尝"**
        dishId: "1397849739276890114",dishName: "辣子鸡"
        **id: "1397849739276890114",image: "f966a38e-0780-40be-bb52-5699d13cb3d9.jpg",isDeleted: 0,name: "辣子鸡",price: 7800,sort: 0,status: 1,updateTime: "2021-05-27 09:38:43"**
        ```
        
        当点击删除小图片时，则调用`delcheck(ind)`删除掉`**checlList**`数组中下标**`ind`**的菜品信息。用于前端的选择新增菜品展示交互。
        
        选择完毕菜品之后，点击确定，则调用`addTableList()`方法，**将`checkList`的JS数组信息转换为JSON串再转为JS对象保存到`dishTable`中。**
        
        并关闭弹窗页面，置空**`checkList`**
        
        ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2052.png)
        
    
    点击确定按钮后，关闭弹窗，数据展示还是通过**`dishTable`**对象进行的数据获取。后续就只需要将重心转移到插入数据上了。
    
    - **在add.html页面的所有数据操作，都是将数据存放到了`ruleform`中。并在点击保存后 将`ruleform`提交给`submitForm(ruleform,false)`**
      
        在`submitForm()`方法中，保存所有的数据信息到**`prams`**中，会处理套餐**setmeal**的基础信息：`**price,status,categoryID**`。并封装好套餐下包含的`**Dish的对象数组**`。
        
        由代码逻辑可以看到，**`setmealDishes`**封装DIsh的数组中仅**保存单个Dish的了`copies，dishId，name，price`。**
        
        ![Untitled](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%20fcee46ea152c4c49b3455bd197b7c5db/Untitled%2053.png)
        
        最后提交的**prams**内的数据格式如下：
        
        ```java
        prams: {categoryId: "1413342269393674242",code: "",description: "asdasdas"
        dishList:[],idType: "1413342269393674242",
        image: "127c9ec3-4971-4e39-91a4-2e5873ff0f99.jpg"
        name: "飒飒大"
        price: 45600
        setmealDishes: [
        			{copies: 1, dishId: '1397849739276890114', name: '辣子鸡', price: 7800},
        			{copies: 1, dishId: '1397850392090947585', name: '组庵鱼翅', price: 4800}
        			{copies: 1, dishId: '1397850851245600769', name: '霸王别姬', price: 12800}
        ]
        status: 1
        ```
        
    
- **后端编码：**
  
    创建DTO类：其实在setmeal表中设置setmealdish集合属性也是可以，只不过这是另一种做法，比较好维护
    
    ```java
    @Data
    public class SetmealDto extends Setmeal {
    
        private List<SetmealDish> setmealDishes;
    
        private String categoryName;
    }
    ```
    
    首先根据cateGoryId查询分类下所有的菜品信息**。/dish/list?categoryId=1397844263642378242**
    
    如果需要根据name获取所有的Dish数据，则也直接获取。**/dish/list?name=鸡**
    
    ```java
    //根基CategoryID或name查询分类下所有的Dish信息
    @GetMapping("/list")
    public Result<List<Dish>> getDishByCategoryId(Long categoryId,String name){
        // log.info("categoryID:{}",categoryId);
        log.info("name:{}",name);
        LambdaQueryWrapper<Dish> dishWrapper = new LambdaQueryWrapper<>();
        **dishWrapper.eq(categoryId!=null,Dish::getCategoryId,categoryId);
        dishWrapper.like(name!=null,Dish::getName,"%"+name+"%");**
        List<Dish> dishList = dishService.list(dishWrapper);
    
        if(dishList!=null){
            return Result.success(dishList);
        }
        return Result.error("未知错误，查询失败");
    }
    ```
    
    点击保存按钮，请求会发送到**/setmeal，数据格式如下**
    
    ```json
    {**"name":"自定套餐","categoryId":"1413342269393674242","idType":"1413342269393674242","price":45600,"code":""**,"dishList":[],
    **"image":"127c9ec3-4971-4e39-91a4-2e5873ff0f99.jpg","description":"商务必备，一餐横扫饥饿做回自己","status":1,**
    **"setmealDishes":[**
    			{"copies":1,"dishId":"1397849739276890114","name":"辣子鸡","price":7800},
    			{"copies":1,"dishId":"1397850392090947585","name":"组庵鱼翅","price":4800},
    			{"copies":1,"dishId":"1397850851245600769","name":"霸王别姬","price":12800}
    	]
    }
    ```
    
    保存SetmealController
    
    ```java
    //根据SetmealDto插入setmeal。同时根据得到的setmealId更新setmealDish
    @PostMapping
    		public Result<String> addSetmeal(@RequestBody SetmealDto setmealDto){
    		boolean b = setmealService.addSetmeal(setmealDto);
    		if(b){
    			  return Result.success("套餐插入成功");
    		}
    			return Result.error("套餐插入失败");
    }
    ```
    
    保存SetmealService
    
    ```java
    //根据SetmealDto插入新的Setmeal数据，同时维护setmeal对应的菜品信息setmealDish
    @Override
    @Transactional
    public boolean addSetmeal(SetmealDto setmealDto) {
        // 首先保存基础的setmeal套餐数据，保存成功后会将setMeal的Id值存入其中
        boolean save = this.save(setmealDto);
        //如果套餐保存成功，则继续保存套餐的菜品信息
        if(save){
            //获取所有的菜品信息，并将setmealID数据存入其中
            List<SetmealDish> setmealDishes = setmealDto.getSetmealDishes();
            Long setmealId = setmealDto.getId();
            setmealDishes = setmealDishes.stream().map(setmealDishe -> {
                setmealDishe.setSetmealId(setmealId);
                return setmealDishe;
            }).collect(Collectors.toList());
            return  setmealDishService.saveBatch(setmealDishes);
        }
        return false;
    }
    ```
    

### 分页查询

前端代码分析：

当套餐信息页面打开后，就会自动调用*`getSetmealPage()`*以Get方式请求**/setmeal/page?page=1&pageSize=10**获取信息，进行数据展示。

当进行菜品信息检索时，也会调用*`getSetmealPage()`*以Get方式请求**/setmeal/page?page=1&pageSize=10&name=ssds**

二者返回信息一致，可以放置到一起。返回的**`setmealDto对象`**则会自动封装到**`tableData`**中

经分析，前端展示界面不需要**`setmealDish`**的数组信息，只需要基础的setmeal以及categoryName信息即可完成展示，点击修改后会自动根据请求后端的菜品信息并作展示

后端代码编写：

SetmealController：

```java
//根据接收参数，分页查询setmeal并获取categoryName放入setmealDto返回
@GetMapping("/page")
public Result<Page> selectAllAndPagition(int page,int pageSize,String name){
		  // 查询setmeal分页数据
		  Page<Setmeal> setmealPage = setmealService.selectAllAndPagition(page, pageSize, name);
		
		  //将setmeal的categoryName查询出来，并保存到setmealDto。封装到分页对象中
		  Page<SetmealDto> setmealDtoPage = setmealDtoService.transforSetmealDtoPage(setmealPage);
		
		  return Result.success(setmealDtoPage);

}
```

SetmealService：

```java
//根据page和pageSize执行分页查询
@Override
public Page<Setmeal> selectAllAndPagition(int page, int pageSize, String name){
    //执行分页
    Page<Setmeal> setmealPage = new Page<>(page,pageSize);
    //根据套餐名称模糊查询
    LambdaQueryWrapper<Setmeal> setmealWrapper = new LambdaQueryWrapper<>();
    setmealWrapper.like(name!=null,Setmeal::getName,name);
    //根据更新时间排序
    setmealWrapper.orderBy(true,true,Setmeal::getUpdateTime);
    //查询数据
    this.page(setmealPage,setmealWrapper);
    return setmealPage;
}
```

SetmealDtoService：

```java
//将前端传递的setmealPage中的setmeal对应的categoryName查询到并封装到setmealDtoPage
@Override
public Page<SetmealDto> transforSetmealDtoPage(Page<Setmeal> setmealPage) {
    //将查询每一个setmealPage拷贝到SetmealDto中
    Page<SetmealDto> setmealDtoPage = new Page<>();
    BeanUtils.copyProperties(setmealPage,setmealDtoPage,"records");
    //查询每一个setmeal的category的Name并将之存储到其中
    List<SetmealDto> setmealDtos = setmealPage.getRecords().stream().map(setmeal -> {
        SetmealDto setmealDto = new SetmealDto();
        BeanUtils.copyProperties(setmeal, setmealDto);
        String categoryName = categoryService.getNameById(setmeal.getCategoryId());
        setmealDto.setCategoryName(categoryName);
        return setmealDto;
    }).collect(Collectors.toList());
    //将保存由Setmeal和对应CatrgoryName的数据存入setmealDtoPage
    setmealDtoPage.setRecords(setmealDtos);
    return setmealDtoPage;
}
```

### **修改套餐**

**前端页面**

当点击套餐后的修改按钮后，会进入add.html即新增套餐的页面。会自动的调用carted钩子函数中的内容。

首先查询到套餐分类信息存储到setMealList中，查询菜品分类信息存储到**`dishType`**中，同时查询处第一个菜品分类的所有菜品存入`**dishAddList**`中。

**以上两个功能已经实现**

随后传入的**id**不为空，则继续执行init()方法，调用*`**querySetmealById*(this.id)`发送GET请求，到/setmeal/${id}，**用于获取setmeal套餐的信息以及包含的具体菜品信息。

最后返回一个`**SetmealDto对象**`，同时对比状态码code值是否为1，如果为1。则将setmealDto中的数据信息，保存到**`ruleform`**中。然后前端直接展示Ruleform的信息。

至此展示数据展示完毕。随后就是完成保存操作。

检查前端请求，发现前端执行修改操作后请求的页面为**/setmeal**使用的请求方式为**Put**

**后端编码：**

SetmealController:

```java
//根据传入的setmealDish数据更新setmeal
@PutMapping
public Result<String> updateSetmeal(@RequestBody SetmealDto setmealDto){
     boolean b = setmealService.updateSetmeal(setmealDto);
    if(b){
        return Result.success("修改成功");
    }
    return Result.error("修改失败");
}
```

SetmealService:

```java
//根据DishDto更新Dish，并删除原有setmealDIsh，插入新的SetmealDish
@Override
@Transactional
public boolean updateSetmeal(SetmealDto setmealDto) {
		//根据传递的setmealId更新setmeal
		boolean b = this.updateById(setmealDto);
		//如果setmeal更新完毕，则更新setmeal的setmealDish
		if(b){
		      Long setmealId = setmealDto.getId();
					//首先删除所有setmealDIsh信息
					boolean remove = setmealDishService.deleteAllBySetmealId(setmealId);
					//删除成功后，插入所有的setmealDish信息
					if(remove){//如果删除失败直接返回false
					            //执行插入操作,
								return setmealDishService.addSetmealDishBySetmealId(setmealDto.getSetmealDishes(),setmealId);
	        }else {
		            return false;
	        }
		   }
    return false;
}
```

SetmealDishService：

```java
//根据setmealID删除对应的所有setmealDish数据

@Override
public boolean deleteAllBySetmealId(Long setmealId) {
    //首先删除所有setmealDIsh信息
    LambdaQueryWrapper<SetmealDish> setmealDishWrapper = new LambdaQueryWrapper<>();
    setmealDishWrapper.eq(SetmealDish::getSetmealId,setmealId);
    return this.remove(setmealDishWrapper);
}

//将setmealID插入setmealDish中，并保存

@Override
public boolean addSetmealDishBySetmealId(List<SetmealDish> setmealDishes, Long setmealId) {
    // 将setmealID插入每一个setmealDish中
    setmealDishes = setmealDishes.stream().map(setmealDish -> {
        setmealDish.setSetmealId(setmealId);
        return setmealDish;
    }).collect(Collectors.toList());
    // 执行批量插入操作
    return this.saveBatch(setmealDishes);
}
```

### 删除启停售套餐

- **删除与批量删除套餐**
  
    后端发送的请求操作均为**/setmeal?ids=1415580119015145474,1574792648284327938。ids为一个String数组，后端处理时需要将String数组拆分并转换为Long类型数组**
    
    传入的时setmealDish的Id值，根据SetmealID值删除setmealDIsh，同时根据setmealID删除setmealDish信息。
    
    删除数据之后，会自动调用初始化init方法，再次从后端获取分页信息的数据
    
    - **后端编码：**
      
        前端会传递一个ids数组，首先将String的ids转换为List<Long>
        
        ```java
        //将String数组转换为List<Long>
        
        private ArrayList<Long> parseStrsToLongList(String ids) {
            String[] split = ids.split(",");
            ArrayList<Long> idss = new ArrayList<>();
            for (String s : split) {
                Long dishId = Long.valueOf(s);
                idss.add(dishId);
            }
            return idss;
        }
        ```
        
        SetmealController：
        
        ```java
        //根据setmealIDs删除所有setmeal，以及setmealID对应的所有setmealDish
        @DeleteMapping
        public Result<String> deleteSetmeal(String ids){
            ArrayList<Long> setmealIds = parseStrsToLongList(ids);
            boolean b = setmealService.deleteBatchByIds(setmealIds);
            if(b){
                return Result.success("删除成功");
            }
            return Result.error("删除失败");
        }
        ```
        
        SetmealService:
        
        ```java
        //根据setmealID删除setmeal，同时删除与setmealId绑定的setmealDish
        @Override
        @Transactional
        public boolean deleteBatchByIds(List<Long> setmealIds) {
        		//首先批量删除setmeal
        		boolean b = this.removeByIds(setmealIds);
        		//如果删除成功,循环遍历setmeal，删除setmealdish数据
        		if(b){
        		        for (Long setmealId : setmealIds) {
        		            setmealDishService.deleteAllBySetmealId(setmealId);
        		        }
        		        return true;
        		    }
            return false;
        }
        ```
        
        setmealDishService：
        
        ```java
        //根据setmealID删除对应的所有setmealDish数据
        @Override
        public boolean deleteAllBySetmealId(Long setmealId) {
        		//首先删除所有setmealDIsh信息
        		LambdaQueryWrapper<SetmealDish> setmealDishWrapper = new LambdaQueryWrapper<>();
            setmealDishWrapper.eq(SetmealDish::getSetmealId,setmealId);
            return this.remove(setmealDishWrapper);
        }
        ```
    
- **启停售与批量起停售**
  
    点击停售后会发送Post类型的**/setmeal/status/0?ids=1575030463306342402到后端。**
    
    其中**/setmeal/status/${params.status}状态是使用的{status}，ids使用JSON方式传递**
    
    后端代码：
    
    SetmealController：
    
    ```java
    //根据setmealIds修改setmeal的状态
    @PostMapping("status/{status}")
    public Result<String> updateStatus(@PathVariable Integer status,String ids){
        ArrayList<Long> setmealIds = parseStrsToLongList(ids);
        boolean b = setmealService.updateStatusByIds(setmealIds, status);
        if(b){
            return Result.success("状态修改成功");
        }
        return Result.error("状态修改失败");
    }
    ```
    
    SetmealService:
    
    ```java
    //根据SetmealIds修改所有的setmeal的Status信息
    @Override
    public boolean updateStatusByIds(List<Long> setmealIds, Integer status) {
    		//首先根据setmealIds获取到需要更细你的setmeal数组
    		List<Setmeal> setmealList = this.listByIds(setmealIds);
    		//修改setmeal的status
    		setmealList = setmealList.stream().map(setmeal -> {
            setmeal.setStatus(status);
            return setmeal;
        }).collect(Collectors.toList());
    		//执行setmeal的状态修改,并返回是否执行成功
    		return this.updateBatchById(setmealList);
    }
    ```
    

